# AI智能巡检系统 - 领域特有知识

## 业务领域知识

### 智能巡检领域核心概念

#### 1.1 巡检类型分类

**页面巡检 (Page Inspection)**
- **定义**: 通过自动化浏览器对Web页面进行截图，并利用AI视觉识别技术对比分析页面变化
- **适用场景**: 数据看板监控、业务报表巡检、用户界面稳定性检查
- **技术实现**: Playwright + 多模态AI分析
- **检测精度**: 支持像素级差异检测和业务逻辑理解

**API接口巡检 (API Inspection)**
- **定义**: 对REST API接口进行自动化调用，分析响应数据的一致性和正确性
- **适用场景**: 微服务接口监控、数据接口稳定性检查、业务逻辑验证
- **技术实现**: HTTP客户端 + JSON数据比较
- **检测维度**: 响应时间、数据格式、业务数据变化

#### 1.2 AI分析模式

**多模态智能分析**
- **图像理解**: 基于通义千问多模态大模型，理解页面截图中的业务数据和布局结构
- **文本提取**: 从图像中提取关键的数值、文本信息进行结构化分析
- **差异识别**: 智能识别两次截图之间的关键业务差异，过滤无关变化
- **上下文理解**: 结合业务场景和历史数据进行智能判断

**Prompt工程技术**
- **业务定制**: 针对不同业务场景设计专门的AI提示词模板
- **参数化支持**: 提示词支持动态参数注入，适应不同的检测需求
- **效果优化**: 基于历史效果反馈，持续优化提示词的准确性
- **模板管理**: 建立完整的提示词模板库，支持版本管理和复用

#### 1.3 智能比较工具链

**阈值比较工具 (ThresholdComparisonTool)**
- **数值阈值**: 支持百分比和绝对值两种阈值比较模式
- **动态阈值**: 根据数值大小自动计算合理的波动阈值
- **分级判断**: 支持正常、警告、异常三级阈值判断
- **业务规则**: 可配置不同业务场景的专门阈值规则

**波动分析工具 (FluctuationAnalysisTool)**
- **趋势分析**: 分析数据在时间维度上的变化趋势
- **异常检测**: 识别超出正常波动范围的异常数据变化
- **季节性识别**: 识别数据的周期性变化模式
- **预测能力**: 基于历史数据预测未来的数据变化趋势

**字符串比较工具 (StringComparisonTool)**
- **精确匹配**: 支持字符串的精确匹配和差异检测
- **模糊匹配**: 基于编辑距离算法的相似度计算
- **格式化处理**: 自动处理单位、分隔符、百分比等格式化字符
- **多语言支持**: 支持中文、英文、特殊字符的处理

#### 1.4 自动化执行引擎

**定时任务调度**
- **灵活调度**: 支持固定频率、Cron表达式等多种调度方式
- **任务分发**: 支持多任务并发执行和资源协调
- **异常处理**: 完善的任务异常处理和重试机制
- **状态管理**: 实时跟踪任务执行状态和进度

**浏览器自动化**
- **多浏览器支持**: 支持Chrome、Firefox、Safari等主流浏览器
- **智能等待**: 自动等待页面加载完成和元素出现
- **登录模拟**: 支持复杂的登录流程和会话管理
- **截图优化**: 高质量截图生成和压缩优化

### 业务规则与算法

#### 2.1 数据比较算法

**字符串数据处理规则**
```java
// 单位处理：去除公共单位进行数值比较
// 例：存在异地汇报有1人 -> 提取数值"1"进行比较
if (containsCommonUnit(value1, value2)) {
    compareNumericValue(extractNumber(value1), extractNumber(value2));
}

// 分隔符处理：按分隔符拆分进行多值比较  
// 例：1/0.1 -> 拆分为[1, 0.1]进行比较
if (containsSeparator(value1, value2)) {
    String[] parts1 = splitBySeparator(value1);
    String[] parts2 = splitBySeparator(value2);
    compareArrays(parts1, parts2);
}

// 百分比处理：去除%符号进行数值比较
// 例：4.59% vs 4.58% -> 比较4.59和4.58
if (isPercentage(value1, value2)) {
    compareNumericValue(removePercent(value1), removePercent(value2));
}
```

**数值波动阈值算法**
```java
// 动态阈值计算规则
public double calculateThreshold(double value1, double value2) {
    // 如果任一值大于10，使用20%阈值
    if (Math.max(value1, value2) > 10) {
        return 0.20; // 20%
    }
    // 如果都小于等于10，使用100%阈值
    else {
        return 1.00; // 100%
    }
}

// 波动计算
public double calculateFluctuation(double value1, double value2) {
    if (value1 == 0 && value2 == 0) return 0;
    if (value1 == 0) return Double.MAX_VALUE;
    return Math.abs(value2 - value1) / Math.abs(value1);
}
```

#### 2.2 AI结果过滤规则

**智能过滤逻辑**
- **无需比较过滤**: 过滤AI标记为"无需比较"的数据点
- **正常波动过滤**: 过滤在合理波动范围内的数据变化
- **一致性过滤**: 过滤实际值与期望值相等的数据
- **关键词过滤**: 根据预设关键词过滤正常状态描述

**过滤关键词库**
```java
// 正常状态关键词
private static final Set<String> NORMAL_KEYWORDS = Set.of(
    "在合理波动范围内", "数据一致", "波动在可接受范围内",
    "未超过预设的阈值", "不报告为异常", "在阈值范围内",
    "正常波动", "合理范围", "可接受", "无需报告"
);

// 异常状态关键词
private static final Set<String> ABNORMAL_KEYWORDS = Set.of(
    "超过阈值", "异常波动", "数据不一致", "显著差异",
    "需要关注", "异常变化", "超出范围"
);
```

#### 2.3 截图质量优化

**智能截图策略**
- **元素等待**: 等待关键业务元素加载完成再截图
- **滚动处理**: 支持长页面的完整截图和分段截图
- **分辨率适配**: 根据页面特点选择最佳截图分辨率
- **压缩优化**: 在保证质量的前提下压缩图片大小

**截图对比优化**
- **区域定位**: 支持指定关键区域进行重点对比
- **背景过滤**: 过滤页面背景和装饰性元素的变化
- **文字识别**: 重点关注数据和文字内容的变化
- **布局稳定**: 处理页面布局微调导致的误报

### 技术实现细节

#### 3.1 工具链架构

**比较工具管理器 (ComparisonToolManager)**
```java
@Component
public class ComparisonToolManager {
    private final Map<String, ComparisonTool> tools = new HashMap<>();
    
    // 注册工具
    public void registerTool(String name, ComparisonTool tool) {
        tools.put(name, tool);
    }
    
    // 智能选择工具
    public ComparisonTool selectTool(Object value1, Object value2) {
        if (isNumeric(value1, value2)) {
            return tools.get("threshold");
        } else if (isString(value1, value2)) {
            return tools.get("string");
        }
        return tools.get("default");
    }
}
```

**工具执行器 (ToolExecutor)**
```java
@Component  
public class ToolExecutor {
    @Autowired
    private ComparisonToolManager toolManager;
    
    public ComparisonResult execute(String toolName, Map<String, Object> args) {
        ComparisonTool tool = toolManager.getTool(toolName);
        return tool.compare(args);
    }
    
    // 批量执行
    public List<ComparisonResult> executeBatch(List<ToolRequest> requests) {
        return requests.parallelStream()
            .map(this::executeRequest)
            .collect(Collectors.toList());
    }
}
```

#### 3.2 AI服务集成

**多模态调用封装**
```java
@Service
public class PicCompareServiceImpl implements PicCompareService {
    
    public void picCompareSingle(InspectionResult result) {
        // 构建多模态对话
        MultiModalConversation conv = new MultiModalConversation(
            Protocol.HTTP.getValue(), 
            dashScopeConfig.getUrl()
        );
        
        // 系统提示词
        String systemPrompt = buildSystemPrompt(result);
        
        // 用户消息（包含图片）
        List<Map<String, String>> contents = Arrays.asList(
            Map.of("image", currentImageBase64),
            Map.of("image", lastImageBase64), 
            Map.of("text", userPrompt)
        );
        
        // 执行AI分析
        GenerationResult aiResult = conv.call(buildGenerationParam(contents));
        
        // 解析结果
        List<InspectionIndicatorDTO> indicators = parseAIResult(aiResult);
        
        // 应用过滤规则
        List<InspectionIndicatorDTO> filteredResults = applyFilterRules(indicators);
        
        // 保存结果
        saveInspectionResult(result, filteredResults);
    }
}
```

#### 3.3 数据处理管道

**结果处理管道**
```java
@Component
public class ResultProcessingPipeline {
    
    // 处理步骤定义
    private final List<ResultProcessor> processors = Arrays.asList(
        new JsonExtractionProcessor(),    // JSON提取
        new DataCleaningProcessor(),      // 数据清洗  
        new FilteringProcessor(),         // 结果过滤
        new ValidationProcessor(),        // 数据验证
        new FormattingProcessor()         // 格式化输出
    );
    
    public ProcessResult process(String rawResult) {
        ProcessResult result = new ProcessResult(rawResult);
        
        for (ResultProcessor processor : processors) {
            result = processor.process(result);
            if (result.hasError()) {
                break;
            }
        }
        
        return result;
    }
}
```

### 领域专业术语

#### 4.1 巡检术语

| 术语 | 英文 | 定义 | 应用场景 |
|------|------|------|----------|
| 巡检任务 | Inspection Task | 系统自动执行的检测任务 | 定时巡检、手动巡检 |
| 差异指标 | Difference Indicator | AI识别的数据不一致点 | 结果分析、异常报告 |
| 阈值比较 | Threshold Comparison | 基于预设阈值的数值判断 | 数值监控、趋势分析 |
| 波动分析 | Fluctuation Analysis | 数据变化趋势的智能分析 | 异常检测、预警机制 |
| 截图对比 | Screenshot Comparison | 页面图像的智能比较分析 | 页面监控、UI测试 |

#### 4.2 AI术语

| 术语 | 英文 | 定义 | 应用场景 |
|------|------|------|----------|
| 多模态分析 | Multimodal Analysis | 同时处理图像和文本的AI分析 | 智能巡检、内容理解 |
| 提示词工程 | Prompt Engineering | 优化AI输入提示的技术方法 | 效果优化、准确性提升 |
| 上下文理解 | Context Understanding | AI对业务场景的智能理解 | 业务分析、智能判断 |
| 结果过滤 | Result Filtering | 智能过滤AI分析结果 | 精度提升、误报减少 |

#### 4.3 技术术语

| 术语 | 英文 | 定义 | 应用场景 |
|------|------|------|----------|
| 工具链管理 | Tool Chain Management | 比较工具的统一管理和调度 | 扩展性、复用性 |
| 异步处理 | Asynchronous Processing | 非阻塞的任务执行模式 | 性能优化、并发处理 |
| 智能重试 | Intelligent Retry | 基于异常类型的智能重试策略 | 可靠性、容错能力 |
| 结果管道 | Result Pipeline | 数据处理的流水线架构 | 数据处理、结果优化 |

### 最佳实践指南

#### 5.1 Prompt设计原则

**明确性原则**
- 清晰描述检测目标和期望结果格式
- 提供具体的业务场景和上下文信息
- 明确指出需要关注的关键指标

**准确性原则**  
- 基于真实业务场景设计测试用例
- 持续优化Prompt以提高检测准确率
- 建立效果评估和反馈机制

**可维护性原则**
- 模块化设计，支持组合和复用
- 建立版本管理和变更跟踪机制
- 文档化Prompt的设计思路和使用方法

#### 5.2 巡检策略优化

**频率控制**
- 根据业务重要性调整巡检频率
- 避免过于频繁的巡检导致资源浪费
- 在关键时间点增加巡检密度

**成本优化**
- 合理控制AI服务调用频次
- 优先处理高价值的业务场景
- 建立成本监控和预算控制机制

**质量保证**
- 建立多层次的质量验证机制
- 定期评估巡检效果和准确性
- 持续优化算法和规则配置

> **注意**: 
> - 本文档中的算法和规则需要根据实际业务场景进行调整
> - AI模型的效果会随着使用和优化逐步提升
> - 建议定期review和更新领域知识库内容
